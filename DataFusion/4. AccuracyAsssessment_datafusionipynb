{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "1dd4434d-03a3-4d82-a2e9-05609a379535",
   "metadata": {},
   "source": [
    "# Accuracy Assessment"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "89cf1b3a-6307-4f18-ad02-8731efba7e52",
   "metadata": {},
   "source": [
    "### Importing libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "4d76ec95-5cf5-4cec-806c-8672617a0ea0",
   "metadata": {},
   "outputs": [],
   "source": [
    "import geopandas as gpd\n",
    "import rasterio\n",
    "import numpy as np\n",
    "from rasterio.sample import sample_gen\n",
    "from sklearn.metrics import accuracy_score, confusion_matrix\n",
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e325b69e-c500-4b12-9f9b-c9c9abbcec5f",
   "metadata": {},
   "source": [
    "#### Overall classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "16160337-a5bf-4603-a4c9-2b796e0724fc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Overall Accuracy: 0.9861111111111112\n",
      "Confusion Matrix:\n",
      "[[9 0 0 0 0 0 0 0]\n",
      " [0 8 1 0 0 0 0 0]\n",
      " [0 0 9 0 0 0 0 0]\n",
      " [0 0 0 9 0 0 0 0]\n",
      " [0 0 0 0 9 0 0 0]\n",
      " [0 0 0 0 0 9 0 0]\n",
      " [0 0 0 0 0 0 9 0]\n",
      " [0 0 0 0 0 0 0 9]]\n",
      "\n",
      "User's Accuracy:\n",
      "Class 1: 1.00\n",
      "Class 2: 1.00\n",
      "Class 3: 0.90\n",
      "Class 4: 1.00\n",
      "Class 5: 1.00\n",
      "Class 6: 1.00\n",
      "Class 7: 1.00\n",
      "Class 8: 1.00\n",
      "\n",
      "Producer's Accuracy:\n",
      "Class 1: 1.00\n",
      "Class 2: 0.89\n",
      "Class 3: 1.00\n",
      "Class 4: 1.00\n",
      "Class 5: 1.00\n",
      "Class 6: 1.00\n",
      "Class 7: 1.00\n",
      "Class 8: 1.00\n",
      "\n",
      "Kappa Coefficient:\n",
      "0.98\n"
     ]
    },
    {
     "ename": "OSError",
     "evalue": "Cannot save file into a non-existent directory: 'C:\\Users\\SkosanaT\\OneDrive - Stellenbosch University\\MAPWAPS\\DataChapter1\\uMzi_ROI\\data\\SPOT_6'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mOSError\u001b[0m                                   Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[3], line 84\u001b[0m\n\u001b[0;32m     82\u001b[0m comparison_df \u001b[38;5;241m=\u001b[39m pd\u001b[38;5;241m.\u001b[39mDataFrame(comparison_data)\n\u001b[0;32m     83\u001b[0m comparison_csv_path \u001b[38;5;241m=\u001b[39m \u001b[38;5;124mr\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mC:\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124mUsers\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124mSkosanaT\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124mOneDrive - Stellenbosch University\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124mMAPWAPS\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124mDataChapter1\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124muMzi_ROI\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124mdata\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124mSPOT_6\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124mcomparison_data.csv\u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[1;32m---> 84\u001b[0m \u001b[43mcomparison_df\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mto_csv\u001b[49m\u001b[43m(\u001b[49m\u001b[43mcomparison_csv_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mindex\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43;01mFalse\u001b[39;49;00m\u001b[43m)\u001b[49m\n\u001b[0;32m     86\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;124mComparison Table saved to: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mcomparison_csv_path\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m)\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\Chapter1\\Lib\\site-packages\\pandas\\util\\_decorators.py:333\u001b[0m, in \u001b[0;36mdeprecate_nonkeyword_arguments.<locals>.decorate.<locals>.wrapper\u001b[1;34m(*args, **kwargs)\u001b[0m\n\u001b[0;32m    327\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mlen\u001b[39m(args) \u001b[38;5;241m>\u001b[39m num_allow_args:\n\u001b[0;32m    328\u001b[0m     warnings\u001b[38;5;241m.\u001b[39mwarn(\n\u001b[0;32m    329\u001b[0m         msg\u001b[38;5;241m.\u001b[39mformat(arguments\u001b[38;5;241m=\u001b[39m_format_argument_list(allow_args)),\n\u001b[0;32m    330\u001b[0m         \u001b[38;5;167;01mFutureWarning\u001b[39;00m,\n\u001b[0;32m    331\u001b[0m         stacklevel\u001b[38;5;241m=\u001b[39mfind_stack_level(),\n\u001b[0;32m    332\u001b[0m     )\n\u001b[1;32m--> 333\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mfunc\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\Chapter1\\Lib\\site-packages\\pandas\\core\\generic.py:3967\u001b[0m, in \u001b[0;36mNDFrame.to_csv\u001b[1;34m(self, path_or_buf, sep, na_rep, float_format, columns, header, index, index_label, mode, encoding, compression, quoting, quotechar, lineterminator, chunksize, date_format, doublequote, escapechar, decimal, errors, storage_options)\u001b[0m\n\u001b[0;32m   3956\u001b[0m df \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(\u001b[38;5;28mself\u001b[39m, ABCDataFrame) \u001b[38;5;28;01melse\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mto_frame()\n\u001b[0;32m   3958\u001b[0m formatter \u001b[38;5;241m=\u001b[39m DataFrameFormatter(\n\u001b[0;32m   3959\u001b[0m     frame\u001b[38;5;241m=\u001b[39mdf,\n\u001b[0;32m   3960\u001b[0m     header\u001b[38;5;241m=\u001b[39mheader,\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   3964\u001b[0m     decimal\u001b[38;5;241m=\u001b[39mdecimal,\n\u001b[0;32m   3965\u001b[0m )\n\u001b[1;32m-> 3967\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mDataFrameRenderer\u001b[49m\u001b[43m(\u001b[49m\u001b[43mformatter\u001b[49m\u001b[43m)\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mto_csv\u001b[49m\u001b[43m(\u001b[49m\n\u001b[0;32m   3968\u001b[0m \u001b[43m    \u001b[49m\u001b[43mpath_or_buf\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3969\u001b[0m \u001b[43m    \u001b[49m\u001b[43mlineterminator\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mlineterminator\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3970\u001b[0m \u001b[43m    \u001b[49m\u001b[43msep\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43msep\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3971\u001b[0m \u001b[43m    \u001b[49m\u001b[43mencoding\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mencoding\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3972\u001b[0m \u001b[43m    \u001b[49m\u001b[43merrors\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43merrors\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3973\u001b[0m \u001b[43m    \u001b[49m\u001b[43mcompression\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mcompression\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3974\u001b[0m \u001b[43m    \u001b[49m\u001b[43mquoting\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mquoting\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3975\u001b[0m \u001b[43m    \u001b[49m\u001b[43mcolumns\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mcolumns\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3976\u001b[0m \u001b[43m    \u001b[49m\u001b[43mindex_label\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mindex_label\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3977\u001b[0m \u001b[43m    \u001b[49m\u001b[43mmode\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3978\u001b[0m \u001b[43m    \u001b[49m\u001b[43mchunksize\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mchunksize\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3979\u001b[0m \u001b[43m    \u001b[49m\u001b[43mquotechar\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mquotechar\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3980\u001b[0m \u001b[43m    \u001b[49m\u001b[43mdate_format\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mdate_format\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3981\u001b[0m \u001b[43m    \u001b[49m\u001b[43mdoublequote\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mdoublequote\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3982\u001b[0m \u001b[43m    \u001b[49m\u001b[43mescapechar\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mescapechar\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3983\u001b[0m \u001b[43m    \u001b[49m\u001b[43mstorage_options\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mstorage_options\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m   3984\u001b[0m \u001b[43m\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\Chapter1\\Lib\\site-packages\\pandas\\io\\formats\\format.py:1014\u001b[0m, in \u001b[0;36mDataFrameRenderer.to_csv\u001b[1;34m(self, path_or_buf, encoding, sep, columns, index_label, mode, compression, quoting, quotechar, lineterminator, chunksize, date_format, doublequote, escapechar, errors, storage_options)\u001b[0m\n\u001b[0;32m    993\u001b[0m     created_buffer \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mFalse\u001b[39;00m\n\u001b[0;32m    995\u001b[0m csv_formatter \u001b[38;5;241m=\u001b[39m CSVFormatter(\n\u001b[0;32m    996\u001b[0m     path_or_buf\u001b[38;5;241m=\u001b[39mpath_or_buf,\n\u001b[0;32m    997\u001b[0m     lineterminator\u001b[38;5;241m=\u001b[39mlineterminator,\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m   1012\u001b[0m     formatter\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfmt,\n\u001b[0;32m   1013\u001b[0m )\n\u001b[1;32m-> 1014\u001b[0m \u001b[43mcsv_formatter\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43msave\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m   1016\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m created_buffer:\n\u001b[0;32m   1017\u001b[0m     \u001b[38;5;28;01massert\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(path_or_buf, StringIO)\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\Chapter1\\Lib\\site-packages\\pandas\\io\\formats\\csvs.py:251\u001b[0m, in \u001b[0;36mCSVFormatter.save\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    247\u001b[0m \u001b[38;5;250m\u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m    248\u001b[0m \u001b[38;5;124;03mCreate the writer & save.\u001b[39;00m\n\u001b[0;32m    249\u001b[0m \u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m    250\u001b[0m \u001b[38;5;66;03m# apply compression and byte/text conversion\u001b[39;00m\n\u001b[1;32m--> 251\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m \u001b[43mget_handle\u001b[49m\u001b[43m(\u001b[49m\n\u001b[0;32m    252\u001b[0m \u001b[43m    \u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mfilepath_or_buffer\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    253\u001b[0m \u001b[43m    \u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mmode\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    254\u001b[0m \u001b[43m    \u001b[49m\u001b[43mencoding\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mencoding\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    255\u001b[0m \u001b[43m    \u001b[49m\u001b[43merrors\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43merrors\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    256\u001b[0m \u001b[43m    \u001b[49m\u001b[43mcompression\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mcompression\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    257\u001b[0m \u001b[43m    \u001b[49m\u001b[43mstorage_options\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mstorage_options\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m    258\u001b[0m \u001b[43m\u001b[49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mas\u001b[39;00m handles:\n\u001b[0;32m    259\u001b[0m     \u001b[38;5;66;03m# Note: self.encoding is irrelevant here\u001b[39;00m\n\u001b[0;32m    260\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mwriter \u001b[38;5;241m=\u001b[39m csvlib\u001b[38;5;241m.\u001b[39mwriter(\n\u001b[0;32m    261\u001b[0m         handles\u001b[38;5;241m.\u001b[39mhandle,\n\u001b[0;32m    262\u001b[0m         lineterminator\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mlineterminator,\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m    267\u001b[0m         quotechar\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mquotechar,\n\u001b[0;32m    268\u001b[0m     )\n\u001b[0;32m    270\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_save()\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\Chapter1\\Lib\\site-packages\\pandas\\io\\common.py:749\u001b[0m, in \u001b[0;36mget_handle\u001b[1;34m(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\u001b[0m\n\u001b[0;32m    747\u001b[0m \u001b[38;5;66;03m# Only for write methods\u001b[39;00m\n\u001b[0;32m    748\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mr\u001b[39m\u001b[38;5;124m\"\u001b[39m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;129;01min\u001b[39;00m mode \u001b[38;5;129;01mand\u001b[39;00m is_path:\n\u001b[1;32m--> 749\u001b[0m     \u001b[43mcheck_parent_directory\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mstr\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mhandle\u001b[49m\u001b[43m)\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m    751\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m compression:\n\u001b[0;32m    752\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m compression \u001b[38;5;241m!=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mzstd\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n\u001b[0;32m    753\u001b[0m         \u001b[38;5;66;03m# compression libraries do not like an explicit text-mode\u001b[39;00m\n",
      "File \u001b[1;32m~\\anaconda3\\envs\\Chapter1\\Lib\\site-packages\\pandas\\io\\common.py:616\u001b[0m, in \u001b[0;36mcheck_parent_directory\u001b[1;34m(path)\u001b[0m\n\u001b[0;32m    614\u001b[0m parent \u001b[38;5;241m=\u001b[39m Path(path)\u001b[38;5;241m.\u001b[39mparent\n\u001b[0;32m    615\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m parent\u001b[38;5;241m.\u001b[39mis_dir():\n\u001b[1;32m--> 616\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mOSError\u001b[39;00m(\u001b[38;5;124mrf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mCannot save file into a non-existent directory: \u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mparent\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
      "\u001b[1;31mOSError\u001b[0m: Cannot save file into a non-existent directory: 'C:\\Users\\SkosanaT\\OneDrive - Stellenbosch University\\MAPWAPS\\DataChapter1\\uMzi_ROI\\data\\SPOT_6'"
     ]
    }
   ],
   "source": [
    "# Define the paths\n",
    "classified_image_file = r'C:\\Users\\User\\Documents\\DataFusion\\DataFusion\\Classified\\datafusion_classified10042014.tif'\n",
    "validation_shapefile_path = r'C:\\Users\\User\\OneDrive - Stellenbosch University\\MAPWAPS\\DataChapter1\\uMzi_ROI\\Train_Val\\Validation_data\\validation_shapefile.shp'\n",
    "\n",
    "# Load validation shapefile as a geodataframe\n",
    "validation_gdf = gpd.read_file(validation_shapefile_path)\n",
    "\n",
    "# Initialize lists to store overall metrics\n",
    "all_validation_values = []\n",
    "all_classified_values = []\n",
    "\n",
    "# Initialize lists to store detailed comparison data\n",
    "comparison_data = []\n",
    "\n",
    "# Open the classified image\n",
    "with rasterio.open(classified_image_file) as classified_image:\n",
    "    # Generate samples of the classified image values at validation point locations\n",
    "    validation_values = []\n",
    "    classified_values = []\n",
    "    \n",
    "    for _, row in validation_gdf.iterrows():\n",
    "        coords = [(row.geometry.x, row.geometry.y)]\n",
    "        sampled_values = list(sample_gen(classified_image, coords))\n",
    "        if sampled_values:\n",
    "            classified_value = sampled_values[0][0]\n",
    "            validation_value = row['ID']  # Assuming 'ID' is the ground truth column name\n",
    "            classified_values.append(classified_value)\n",
    "            validation_values.append(validation_value)\n",
    "            \n",
    "            # Store comparison data\n",
    "            comparison_data.append({'Validation Value': validation_value, 'Classified Value': classified_value})\n",
    "    \n",
    "    # Append to overall lists\n",
    "    all_validation_values.extend(validation_values)\n",
    "    all_classified_values.extend(classified_values)\n",
    "\n",
    "# Calculate overall accuracy\n",
    "accuracy = accuracy_score(all_validation_values, all_classified_values)\n",
    "conf_matrix = confusion_matrix(all_validation_values, all_classified_values)\n",
    "\n",
    "# Calculate User's and Producer's Accuracy\n",
    "def calculate_accuracy(conf_matrix):\n",
    "    total = np.sum(conf_matrix)\n",
    "    num_classes = conf_matrix.shape[0]\n",
    "    \n",
    "    user_accuracy = np.diag(conf_matrix) / np.sum(conf_matrix, axis=0)\n",
    "    producer_accuracy = np.diag(conf_matrix) / np.sum(conf_matrix, axis=1)\n",
    "    \n",
    "    return user_accuracy, producer_accuracy\n",
    "\n",
    "user_accuracy, producer_accuracy = calculate_accuracy(conf_matrix)\n",
    "\n",
    "# Calculate Kappa Coefficient\n",
    "def calculate_kappa(conf_matrix):\n",
    "    total = np.sum(conf_matrix)\n",
    "    sum_po = np.sum(np.diag(conf_matrix))\n",
    "    sum_pe = np.sum(np.sum(conf_matrix, axis=0) * np.sum(conf_matrix, axis=1)) / total\n",
    "    kappa = (sum_po - sum_pe) / (total - sum_pe)\n",
    "    return kappa\n",
    "\n",
    "kappa = calculate_kappa(conf_matrix)\n",
    "\n",
    "print(\"Overall Accuracy:\", accuracy)\n",
    "print(\"Confusion Matrix:\")\n",
    "print(conf_matrix)\n",
    "\n",
    "# Print User's Accuracy\n",
    "print(\"\\nUser's Accuracy:\")\n",
    "for i, acc in enumerate(user_accuracy):\n",
    "    print(f\"Class {i + 1}: {acc:.2f}\")\n",
    "\n",
    "# Print Producer's Accuracy\n",
    "print(\"\\nProducer's Accuracy:\")\n",
    "for i, acc in enumerate(producer_accuracy):\n",
    "    print(f\"Class {i + 1}: {acc:.2f}\")\n",
    "\n",
    "# Print Kappa Coefficient\n",
    "print(\"\\nKappa Coefficient:\")\n",
    "print(f\"{kappa:.2f}\")\n",
    "\n",
    "# Create and save comparison DataFrame\n",
    "comparison_df = pd.DataFrame(comparison_data)\n",
    "comparison_csv_path = r'C:\\Users\\SkosanaT\\OneDrive - Stellenbosch University\\MAPWAPS\\DataChapter1\\uMzi_ROI\\data\\SPOT_6\\comparison_data.csv'\n",
    "comparison_df.to_csv(comparison_csv_path, index=False)\n",
    "\n",
    "print(f\"\\nComparison Table saved to: {comparison_csv_path}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "93d11021-e3fa-4c44-bbae-1aae6bc3207e",
   "metadata": {},
   "source": [
    "#### Inter accuracy assessment"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "63c3d104-2c4e-4ade-a32e-a03e6831c144",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Overall Accuracy: 1.0\n",
      "Confusion Matrix:\n",
      "[[27  0]\n",
      " [ 0 45]]\n",
      "\n",
      "Kappa Coefficient:\n",
      "1.00\n",
      "\n",
      "Comparison Table:\n",
      "    Validation Value  Classified Value Grouped Validation Grouped Classified\n",
      "0                1.0                 1     Invasive Alien     Invasive Alien\n",
      "1                6.0                 6       Non-Invasive       Non-Invasive\n",
      "2                6.0                 6       Non-Invasive       Non-Invasive\n",
      "3                1.0                 1     Invasive Alien     Invasive Alien\n",
      "4                6.0                 6       Non-Invasive       Non-Invasive\n",
      "..               ...               ...                ...                ...\n",
      "67               8.0                 8       Non-Invasive       Non-Invasive\n",
      "68               5.0                 5       Non-Invasive       Non-Invasive\n",
      "69               7.0                 7       Non-Invasive       Non-Invasive\n",
      "70               8.0                 8       Non-Invasive       Non-Invasive\n",
      "71               5.0                 5       Non-Invasive       Non-Invasive\n",
      "\n",
      "[72 rows x 4 columns]\n"
     ]
    }
   ],
   "source": [
    "# Initialize lists to store overall metrics\n",
    "all_validation_values = []\n",
    "all_classified_values = []\n",
    "\n",
    "# Initialize lists to store detailed comparison data\n",
    "comparison_data = []\n",
    "\n",
    "# Define groups\n",
    "def group_class(value):\n",
    "    if value in [1, 2, 3]:  # Invasive alien plants\n",
    "        return 'Invasive Alien'\n",
    "    elif value in [4, 5, 6, 7, 8]:  # Non-invasive plants\n",
    "        return 'Non-Invasive'\n",
    "    else:\n",
    "        return 'Unknown'\n",
    "\n",
    "\n",
    "# Open the classified image\n",
    "with rasterio.open(classified_image_file) as classified_image:\n",
    "    # Generate samples of the classified image values at validation point locations\n",
    "    validation_values = []\n",
    "    classified_values = []\n",
    "    \n",
    "    for _, row in validation_gdf.iterrows():\n",
    "        coords = [(row.geometry.x, row.geometry.y)]\n",
    "        sampled_values = list(sample_gen(classified_image, coords))\n",
    "        if sampled_values:\n",
    "            classified_value = sampled_values[0][0]\n",
    "            validation_value = row['ID']  # Assuming 'ID' is the ground truth column name\n",
    "            classified_values.append(classified_value)\n",
    "            validation_values.append(validation_value)\n",
    "            \n",
    "            # Store comparison data\n",
    "            comparison_data.append({\n",
    "                'Validation Value': validation_value,\n",
    "                'Classified Value': classified_value,\n",
    "                'Grouped Validation': group_class(validation_value),\n",
    "                'Grouped Classified': group_class(classified_value)\n",
    "            })\n",
    "    \n",
    "    # Append to overall lists\n",
    "    all_validation_values.extend(validation_values)\n",
    "    all_classified_values.extend(classified_values)\n",
    "\n",
    "# Group the values\n",
    "grouped_validation_values = [group_class(value) for value in all_validation_values]\n",
    "grouped_classified_values = [group_class(value) for value in all_classified_values]\n",
    "\n",
    "# Calculate overall accuracy for the grouped classes\n",
    "accuracy = accuracy_score(grouped_validation_values, grouped_classified_values)\n",
    "conf_matrix = confusion_matrix(grouped_validation_values, grouped_classified_values, labels=['Invasive Alien', 'Non-Invasive'])\n",
    "\n",
    "# Calculate Kappa Coefficient\n",
    "def calculate_kappa(conf_matrix):\n",
    "    total = np.sum(conf_matrix)\n",
    "    sum_po = np.sum(np.diag(conf_matrix))  # Observed agreement\n",
    "    sum_pe = np.sum(np.sum(conf_matrix, axis=0) * np.sum(conf_matrix, axis=1)) / total  # Expected agreement\n",
    "    kappa = (sum_po - sum_pe) / (total - sum_pe) if (total - sum_pe) != 0 else 0\n",
    "    return kappa\n",
    "\n",
    "kappa = calculate_kappa(conf_matrix)\n",
    "\n",
    "print(\"Overall Accuracy:\", accuracy)\n",
    "print(\"Confusion Matrix:\")\n",
    "print(conf_matrix)\n",
    "\n",
    "# Print Kappa Coefficient\n",
    "print(\"\\nKappa Coefficient:\")\n",
    "print(f\"{kappa:.2f}\")\n",
    "\n",
    "# Create and print comparison DataFrame\n",
    "comparison_df = pd.DataFrame(comparison_data)\n",
    "print(\"\\nComparison Table:\")\n",
    "print(comparison_df)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1eaa154d-8f2e-46a6-a110-19b74582d1c8",
   "metadata": {},
   "source": [
    "#### Intra accuracy assessment"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "e35ea6aa-85c2-4c1f-bd37-c81177031ac8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Overall Accuracy: 0.9861111111111112\n",
      "Confusion Matrix:\n",
      "[[ 0  0  0  0]\n",
      " [ 0  8  1  0]\n",
      " [ 0  0  9  0]\n",
      " [ 0  0  0 45]]\n",
      "\n",
      "Kappa Coefficient:\n",
      "0.96\n",
      "\n",
      "Comparison Table:\n",
      "    Validation Value  Classified Value Grouped Validation Grouped Classified\n",
      "0                1.0                 1    Invasive Alien     Invasive Alien \n",
      "1                6.0                 6       Non-Invasive       Non-Invasive\n",
      "2                6.0                 6       Non-Invasive       Non-Invasive\n",
      "3                1.0                 1    Invasive Alien     Invasive Alien \n",
      "4                6.0                 6       Non-Invasive       Non-Invasive\n",
      "..               ...               ...                ...                ...\n",
      "67               8.0                 8       Non-Invasive       Non-Invasive\n",
      "68               5.0                 5       Non-Invasive       Non-Invasive\n",
      "69               7.0                 7       Non-Invasive       Non-Invasive\n",
      "70               8.0                 8       Non-Invasive       Non-Invasive\n",
      "71               5.0                 5       Non-Invasive       Non-Invasive\n",
      "\n",
      "[72 rows x 4 columns]\n"
     ]
    }
   ],
   "source": [
    "# Initialize lists to store overall metrics\n",
    "all_validation_values = []\n",
    "all_classified_values = []\n",
    "\n",
    "# Initialize lists to store detailed comparison data\n",
    "comparison_data = []\n",
    "\n",
    "# Define groups\n",
    "def group_class(value):\n",
    "    if value == 1:  # Black Wattle\n",
    "        return 'Invasive Alien '  # Black Wattle\n",
    "    elif value == 2:  # Gum\n",
    "        return 'Invasive Alien 2'  # Gum\n",
    "    elif value == 3:  # Silver Wattle\n",
    "        return 'Invasive Alien 3'  # Silver Wattle\n",
    "    elif value in [4, 5, 6, 7, 8]:  # Non-invasive plants\n",
    "        return 'Non-Invasive'\n",
    "    else:\n",
    "        return 'Unknown'\n",
    "    \n",
    "# Open the classified image\n",
    "with rasterio.open(classified_image_file) as classified_image:\n",
    "    # Generate samples of the classified image values at validation point locations\n",
    "    validation_values = []\n",
    "    classified_values = []\n",
    "    \n",
    "    for _, row in validation_gdf.iterrows():\n",
    "        coords = [(row.geometry.x, row.geometry.y)]\n",
    "        sampled_values = list(sample_gen(classified_image, coords))\n",
    "        if sampled_values:\n",
    "            classified_value = sampled_values[0][0]\n",
    "            validation_value = row['ID']  # Assuming 'ID' is the ground truth column name\n",
    "            classified_values.append(classified_value)\n",
    "            validation_values.append(validation_value)\n",
    "            \n",
    "            # Store comparison data\n",
    "            comparison_data.append({\n",
    "                'Validation Value': validation_value,\n",
    "                'Classified Value': classified_value,\n",
    "                'Grouped Validation': group_class(validation_value),\n",
    "                'Grouped Classified': group_class(classified_value)\n",
    "            })\n",
    "    \n",
    "    # Append to overall lists\n",
    "    all_validation_values.extend(validation_values)\n",
    "    all_classified_values.extend(classified_values)\n",
    "\n",
    "# Group the values\n",
    "grouped_validation_values = [group_class(value) for value in all_validation_values]\n",
    "grouped_classified_values = [group_class(value) for value in all_classified_values]\n",
    "\n",
    "# Calculate overall accuracy for the grouped classes\n",
    "accuracy = accuracy_score(grouped_validation_values, grouped_classified_values)\n",
    "conf_matrix = confusion_matrix(\n",
    "    grouped_validation_values,\n",
    "    grouped_classified_values,\n",
    "    labels=[\n",
    "        'Invasive Alien 1',  # Black Wattle\n",
    "        'Invasive Alien 2',  # Gum\n",
    "        'Invasive Alien 3',  # Silver Wattle\n",
    "        'Non-Invasive'       # Classes 4-8\n",
    "    ]\n",
    ")\n",
    "\n",
    "# Calculate Kappa Coefficient\n",
    "def calculate_kappa(conf_matrix):\n",
    "    total = np.sum(conf_matrix)\n",
    "    sum_po = np.sum(np.diag(conf_matrix))  # Observed agreement\n",
    "    sum_pe = np.sum(np.sum(conf_matrix, axis=0) * np.sum(conf_matrix, axis=1)) / total  # Expected agreement\n",
    "    kappa = (sum_po - sum_pe) / (total - sum_pe) if (total - sum_pe) != 0 else 0\n",
    "    return kappa\n",
    "\n",
    "kappa = calculate_kappa(conf_matrix)\n",
    "\n",
    "print(\"Overall Accuracy:\", accuracy)\n",
    "print(\"Confusion Matrix:\")\n",
    "print(conf_matrix)\n",
    "\n",
    "# Print Kappa Coefficient\n",
    "print(\"\\nKappa Coefficient:\")\n",
    "print(f\"{kappa:.2f}\")\n",
    "\n",
    "# Create and print comparison DataFrame\n",
    "comparison_df = pd.DataFrame(comparison_data)\n",
    "print(\"\\nComparison Table:\")\n",
    "print(comparison_df)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "02363962-143e-42b3-92d8-4d7bde5d5a3b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
